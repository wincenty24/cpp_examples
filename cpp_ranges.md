
### ranges::to (C++23)

constructs a new non-view object from an input range

```c++
#include <iostream>
#include <ranges>
#include <vector>
 
template<class T, class A>
class VectorView : public std::ranges::view_interface<VectorView<T, A>>
{
public:
    VectorView() = default;
 
    VectorView(const std::vector<T, A>& vec) :
        m_begin(vec.cbegin()), m_end(vec.cend())
    {}
 
    auto begin() const { return m_begin; }
 
    auto end() const { return m_end; }
 
private:
    typename std::vector<T, A>::const_iterator m_begin{}, m_end{};
};
 
int main()
{
    std::vector<int> v = {1, 4, 9, 16};
 
    VectorView view_over_v{v};
 
    // We can iterate with begin() and end().
    for (int n : view_over_v)
        std::cout << n << ' ';
    std::cout << '\n';
 
    // We get operator[] for free when inheriting from view_interface
    // since we satisfy the random_access_range concept.
    for (std::ptrdiff_t i = 0; i != view_over_v.size(); ++i)
        std::cout << "v[" << i << "] = " << view_over_v[i] << '\n';
}
/*
1 4 9 16
v[0] = 1
v[1] = 4
v[2] = 9
v[3] = 16
*/
```


### ranges::subrange (C++20)
   
combines an iterator-sentinel pair into a view

```c++
#include <map>
#include <print>
#include <ranges>
 
void make_uppercase(char& v)
{
    v += 'A' - 'a';
}
 
void uppercase_transform(std::multimap<int, char>& m, int k)
{
    auto [first, last] = m.equal_range(k);
    for (auto& [_, v] : std::ranges::subrange(first, last))
        make_uppercase(v);
}
 
int main()
{
    std::multimap<int, char> mm{{4, 'a'}, {3, '-'}, {4, 'b'}, {5, '-'}, {4, 'c'}};
    std::println("Before: {}", mm);
    uppercase_transform(mm, 4);
    std::println("After:  {}", mm);
}
/*

Before: {3: '-', 4: 'a', 4: 'b', 4: 'c', 5: '-'}
After:  {3: '-', 4: 'A', 4: 'B', 4: 'C', 5: '-'}
*/
```

### ranges::empty_view (C++20)
### views::empty (C++20)
 
an empty view with no elements

```c++
#include <ranges>
 
int main()
{
    namespace ranges = std::ranges;
 
    ranges::empty_view<long> e;
    static_assert(ranges::empty(e)); // uses operator bool
    static_assert(0 == e.size());
    static_assert(nullptr == e.data());
    static_assert(nullptr == e.begin());
    static_assert(nullptr == e.end());
    static_assert(nullptr == e.cbegin());
    static_assert(nullptr == e.cend());
}
```

### ranges::single_view (C++20)
### views::single (C++20)
 
a view that contains a single element of a specified value

```c++
#include <iomanip>
#include <iostream>
#include <ranges>
#include <string>
#include <tuple>
 
int main()
{
    constexpr std::ranges::single_view sv1{3.1415}; // uses (const T&) constructor
    static_assert(sv1);
    static_assert(not sv1.empty());
 
    std::cout << "1) *sv1.data(): " << *sv1.data() << '\n'
              << "2) *sv1.begin(): " << *sv1.begin() << '\n'
              << "3)  sv1.size(): " << sv1.size() << '\n'
              << "4)  distance: " << std::distance(sv1.begin(), sv1.end()) << '\n';
 
    std::string str{"C++20"};
    std::cout << "5)  str = " << std::quoted(str) << '\n';
    std::ranges::single_view sv2{std::move(str)}; // uses (T&&) constructor
    std::cout << "6) *sv2.data(): " << std::quoted(*sv2.data()) << '\n'
              << "7)  str = " << std::quoted(str) << '\n';
 
    std::ranges::single_view<std::tuple<int, double, std::string>>
        sv3{std::in_place, 42, 3.14, "ðŸ˜„"}; // uses (std::in_place_t, Args&&... args)
 
    std::cout << "8)  sv3 holds a tuple: { "
              << std::get<0>(sv3[0]) << ", "
              << std::get<1>(sv3[0]) << ", "
              << std::get<2>(sv3[0]) << " }\n";

/*
1) *sv1.data(): 3.1415
2) *sv1.begin(): 3.1415
3)  sv1.size(): 1
4)  distance: 1
5)  str = "C++20"
6) *sv2.data(): "C++20"
7)  str = ""
8)  sv3 holds a tuple: { 42, 3.14, ðŸ˜„ }
*/
}
```

### ranges::iota_view (C++20)
### views::iota (C++20)

a view consisting of a sequence generated by repeatedly incrementing an initial value

```c++
#include <algorithm>
#include <iostream>
#include <ranges>
 
struct Bound
{
    int bound;
    bool operator==(int x) const { return x == bound; }
};
 
int main()
{
    for (int i : std::ranges::iota_view{1, 10})
        std::cout << i << ' ';
    std::cout << '\n';
 
    for (int i : std::views::iota(1, 10))
        std::cout << i << ' ';
    std::cout << '\n';
 
    for (int i : std::views::iota(1, Bound{10}))
        std::cout << i << ' ';
    std::cout << '\n';
 
    for (int i : std::views::iota(1) | std::views::take(9))
        std::cout << i << ' ';
    std::cout << '\n';
 
    std::ranges::for_each(std::views::iota(1, 10),
                          [](int i){ std::cout << i << ' '; });
    std::cout << '\n';
/*
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8 9
*/
}
```
### ranges::repeat_view (C++23)
### views::repeat (C++23)
   
a view consisting of a generated sequence by repeatedly producing the same value

```c++
#include <iostream>
#include <ranges>
#include <string_view>
using namespace std::literals;
 
int main()
{
    // bounded overload
    for (auto s : std::views::repeat("C++"sv, 3))
        std::cout << s << ' ';
    std::cout << '\n';
 
    // unbounded overload
    for (auto s : std::views::repeat("I know that you know that"sv)
                | std::views::take(3))
        std::cout << s << ' ';
    std::cout << "...\n";
/*
C++ C++ C++
I know that you know that I know that you know that I know that you know that ...
*/
}
```

### ranges::basic_istream_view (C++20)
### views::istream (C++20)
 
a view consisting of the elements obtained by successive application of operator>> on the associated input stream
```c++
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <ranges>
#include <sstream>
#include <string>
 
int main()
{
    auto words = std::istringstream{"today is yesterdayâ€™s tomorrow"};
    for (const auto& s : std::views::istream<std::string>(words))
        std::cout << std::quoted(s, '/') << ' ';
    std::cout << '\n';
 
    auto floats = std::istringstream{"1.1  2.2\t3.3\v4.4\f55\n66\r7.7  8.8"};
    std::ranges::copy
    (
        std::views::istream<float>(floats),
        std::ostream_iterator<float>{std::cout, ", "}
    );
    std::cout << '\n';
/*
/today/ /is/ /yesterdayâ€™s/ /tomorrow/
1.1, 2.2, 3.3, 4.4, 55, 66, 7.7, 8.8,
*/
}
```

### ranges::range_adaptor_closure 23

helper base class template for defining a range adaptor closure object

```c++
#include <ranges>
#include <string_view>
 
// Define Slice as a range adaptor closure
struct Slice : std::ranges::range_adaptor_closure<Slice>
{
    std::size_t start = 0;
    std::size_t end = std::string_view::npos;
 
    constexpr std::string_view operator()(std::string_view sv) const
    {
        return sv.substr(start, end - start);
    }
};
 
int main()
{
    constexpr std::string_view str = "01234567";
 
    constexpr Slice slicer{.start = 1, .end = 6};
 
    // use slicer as a normal function object
    constexpr auto sv1 = slicer(str);
    static_assert(sv1 == "12345");
 
    // use slicer as a range adaptor closure object
    constexpr auto sv2 = str | slicer;
    static_assert(sv2 == "12345");
 
    // range adaptor closures can be composed
    constexpr auto slice_and_drop = slicer | std::views::drop(2);
    static_assert(std::string_view(str | slice_and_drop) == "345");
}
```

### views::all_t (C++20)
### views::all (C++20)

a view that includes all elements of a range

```C++
int main()
{
    std::vector<int> v{0, 1, 2, 3, 4, 5};
    for (int n : snntd::views::all(v) | std::views::take(2))
        std::cout << n << ' ';
    std::cout << '\n';
    // 0 1
}
```

### ranges::ref_view (C++20)

a view of the elements of some other range

```C++
#include <iostream>
#include <ranges>
 
int main()
{
    const std::string s{"cosmos"};
 
    const std::ranges::take_view tv{s, 3};
    const std::ranges::ref_view rv{tv};
 
    std::cout
        << std::boolalpha
        << "call empty() : " << rv.empty() << '\n'
        << "call size()  : " << rv.size() << '\n'
        << "call begin() : " << *rv.begin() << '\n'
        << "call end()   : " << *(rv.end() - 1) << '\n'
        << "call data()  : " << rv.data() << '\n'
        << "call base()  : " << rv.base().size() << '\n' // ~> tv.size()
        << "range-for    : ";
 
    for (const auto c : rv)
        std::cout << c;
    std::cout << '\n';
}
/*
    call empty() : false
    call size()  : 3
    call begin() : c
    call end()   : s
    call data()  : cosmos
    call base()  : 3
    range-for    : cos
*/
```

### ranges::owning_view (C++20)

a view with unique ownership of some range. Owning_view is a view that has unique ownership of a range. `It is move-only and stores that range within it`.

// has deleted = operator/copy constructor deleted
// has move operator/ move constructor

```C++

```

### ranges::filter_view

### views::filter (C++20)

a view that consists of the elements of a range that satisfies a predicate

```C++
#include <iostream>
#include <ranges>
 
int main()
{
    auto even = [](int i) { return 0 == i % 2; };
    auto square = [](int i) { return i * i; };
 
    for (int i : std::views::iota(0, 6)
               | std::views::filter(even)
               | std::views::transform(square))
        std::cout << i << ' ';
    std::cout << '\n';
}
/*
    0 4 16
*/
```

### ranges::transform_view (C++20)

### views::transform (C++20)

a view of a sequence that applies a transformation function to each element

```C++
#include <algorithm>
#include <cstdio>
#include <iterator>
#include <ranges>
#include <string>
 
char rot13a(const char x, const char a)
{
    return a + (x - a + 13) % 26;
}
 
char rot13(const char x)
{
    if ('Z' >= x and x >= 'A')
        return rot13a(x, 'A');
 
    if ('z' >= x and x >= 'a')
        return rot13a(x, 'a');
 
    return x;
}
 
int main()
{
    auto show = [](const unsigned char x) { std::putchar(x); };
 
    std::string in{"cppreference.com\n"};
    std::ranges::for_each(in, show);
    std::ranges::for_each(in | std::views::transform(rot13), show);
 
    std::string out;
    std::ranges::copy(std::views::transform(in, rot13), std::back_inserter(out));
    std::ranges::for_each(out, show);
    std::ranges::for_each(out | std::views::transform(rot13), show);
}
/*
    cppreference.com
    pccersrerapr.pbz
    pccersrerapr.pbz
    cppreference.com
*/
```

### ranges::take_view (C++20)

### views::take (C++20)

a view consisting of the first N elements of another view

```c++
#include <algorithm>
#include <iostream>
#include <ranges>
 
int main()
{
    namespace views = std::views;
    auto print = [](char x){ std::cout << x; };
 
    for (const char nums[]{'1', '2', '3'};
         int n : views::iota(0, 5))
    {
        std::cout << "take(" << n << "): ";
        // safely takes only upto min(n, nums.size()) elements:
        std::ranges::for_each(nums | views::take(n), print);
        std::cout << '\n';
    }
}
    /*
    take(0): 
    take(1): 1
    take(2): 12
    take(3): 123
    take(4): 123
    */
```

### ranges::take_while_view (C++20)

### views::take_while (C++20)

a view consisting of the initial elements of another view, until the first element on which a predicate returns false

```c++
int main()
{
    for (int year : std::views::iota(2020)
                  | std::views::take_while([](int y){ return y < 2026; }))
        std::cout << year << ' ';
    std::cout << '\n';
 
    const char note[]{"Today is yesterday's tomorrow!..."};
    auto not_dot = [](char c){ return c != '.'; };
    for (char x : std::ranges::take_while_view(note, not_dot))
        std::cout << x;
    std::cout << '\n';
}
/*
    2020 2021 2022 2023 2024 2025
    Today is yesterday's tomorrow!
*/
```

### ranges::drop_view (C++20)

### views::drop (C++20)
  
a view consisting of elements of another view, skipping the first N elements
(class template) (range adaptor object)

```c++
#include <iostream>
#include <ranges>
 
int main()
{
    const auto nums = {1, 2, 3, 4, 5, 6, 7};
 
    std::cout << "drop " << 2 << ": ";
    for (int i : std::ranges::drop_view{nums, 2})
        std::cout << i << ' ';
    std::cout << '\n';
 
    std::cout << "drop " << 3 << ": ";
    for (int i : nums | std::views::drop(3))
        std::cout << i << ' ';
    std::cout << '\n';
}
/*
    drop 2: 3 4 5 6 7
    drop 3: 4 5 6 7
*/
```

### ranges::drop_while_view (C++20)

### views::drop_while (C++20)

a view consisting of the elements of another view, skipping the initial subsequence of elements until the first element where the predicate returns false

```c++
int main()
{
    static constexpr auto v = {0, 1, 2, 3, 4, 5};
    for (int n : v | std::views::drop_while([](int i) { return i < 3; }))
        std::cout << n << ' ';
    std::cout << '\n';
}
/*
    3 4 5
*/
```

### ranges::join_view (C++20)

### views::join (C++20)
  
a view consisting of the sequence obtained from flattening a view of ranges

```c++
#include <iostream>
#include <ranges>
#include <string_view>
#include <vector>
 
int main()
{
    using namespace std::literals;
 
    const auto bits = {"https:"sv, "//"sv, "cppreference"sv, "."sv, "com"sv};
    for (char const c : bits | std::views::join)
        std::cout << c;
    std::cout << '\n';
 
    const std::vector<std::vector<int>> v{{1, 2}, {3, 4, 5}, {6}, {7, 8, 9}};
    auto jv = std::ranges::join_view(v);
    for (int const e : jv)
        std::cout << e << ' ';
    std::cout << '\n';
}
/*
    https://cppreference.com
    1 2 3 4 5 6 7 8 9
*/
```

### ranges::split_view (C++20)

### views::split (C++20)

a view over the subranges obtained from splitting another view using a delimiter

```c++
#include <iomanip>
#include <iostream>
#include <ranges>
#include <string_view>
 
int main()
{
    using std::operator""sv;
    constexpr auto words{"Hello^_^C++^_^20^_^!"sv};
    constexpr auto delim{"^_^"sv};
 
    for (const auto word : std::views::split(words, delim))
        // with string_view's C++23 range constructor:
        std::cout << std::quoted(std::string_view(word)) << ' ';
    std::cout << '\n';
}
/*
    "Hello" "C++" "20" "!"
*/
```

### ranges::lazy_split_view (C++20)

### views::lazy_split (C++20)
  
a view over the subranges obtained from splitting another view using a delimiter

```c++
#include <algorithm>
#include <iostream>
#include <ranges>
#include <string_view>
 
auto print = [](auto const& view)
{
    // `view` is of std::views::lazy_split_view::__outer_iterator::value_type
 
    for (std::cout << "{ "; const auto element : view)
        std::cout << element << ' ';
    std::cout << "} ";
};
 
int main()
{
    constexpr static auto source = {0, 1, 0, 2, 3, 0, 4, 5, 6, 0, 7, 8, 9};
    constexpr int delimiter{0};
    constexpr std::ranges::lazy_split_view outer_view{source, delimiter};
    std::cout << "splits[" << std::ranges::distance(outer_view) << "]:  ";
    for (auto const& inner_view: outer_view)
        print(inner_view);
 
    constexpr std::string_view hello{"Hello C++ 20 !"};
    std::cout << "\n" "substrings: ";
    std::ranges::for_each(hello | std::views::lazy_split(' '), print);
 
    constexpr std::string_view text{"Hello-+-C++-+-20-+-!"};
    constexpr std::string_view delim{"-+-"};
    std::cout << "\n" "substrings: ";
    std::ranges::for_each(text | std::views::lazy_split(delim), print);
}s
/*
    splits[5]:  { } { 1 } { 2 3 } { 4 5 6 } { 7 8 9 }
    substrings: { H e l l o } { C + + } { 2 0 } { ! }
    substrings: { H e l l o } { C + + } { 2 0 } { ! }
*/
```

#### Now lets compare

1 split (Eager Evaluation):
`Eager Execution`: The split function generally splits the entire input (like a string) into a collection (e.g., std::vector<std::string>) of all substrings at once.
`Immediate Output`: The function immediately returns the entire collection of substrings.
`Memory Usage`: It may consume more memory upfront since it stores all the resulting substrings in a collection.
`Use Case`: Suitable when you need all parts of the split string available immediately for processing.

```c++
std::vector<std::string> split(const std::string &str, char delimiter) {
    std::vector<std::string> result;
    std::string token;
    std::stringstream ss(str);
    while (std::getline(ss, token, delimiter)) {
        result.push_back(token);
    }
    return result;
}
```

2 lazy_split (Lazy Evaluation):
`Lazy Execution`: lazy_split typically generates substrings on-demand, yielding results one by one rather than all at once.
`Iterative Output`: It often returns an iterator or a generator-like object that can be used to traverse the substrings as needed.
`Memory Efficiency`: More memory-efficient, as it doesn't store all substrings at once, but rather computes each as you iterate over the results.
`Use Case`: Ideal when working with very large strings or when only a subset of the results is needed.

```c++
class LazySplit {
public:
    LazySplit(const std::string& str, char delimiter) : str_(str), delimiter_(delimiter), start_(0) {}
    
    std::string next() {
        size_t end = str_.find(delimiter_, start_);
        if (end == std::string::npos) {
            end = str_.size();
        }
        std::string token = str_.substr(start_, end - start_);
        start_ = end + 1;
        return token;
    }

    bool has_next() const {
        return start_ < str_.size();
    }

private:
    std::string str_;
    char delimiter_;
    size_t start_;
};
```

### views::counted (C++20)

creates a subrange from an iterator and a count

```c++
#include <iostream>
#include <ranges>
 
int main()
{
    const int a[]{1, 2, 3, 4, 5, 6, 7};
    for (int i : std::views::counted(a, 3))
        std::cout << i << ' ';
    std::cout << '\n';
 
    const auto il = {1, 2, 3, 4, 5};
    for (int i : std::views::counted(il.begin() + 1, 3))
        std::cout << i << ' ';
    std::cout << '\n';
}
/*
1 2 3
2 3 4
*/
```

### ranges::common_view (C++20)

### views::common (C++20)
  
converts a view into a common_range

std::ranges::common is a utility from the C++20 Ranges library. It is used to adapt a range to ensure that it has a "common" iterator and sentinel type, meaning that the begin and end of the range return the same type of iterator.

```c++
int main()
{
    auto v1 = {1, 2, 3, 4, 5};
    auto i1 = std::counted_iterator{v1.begin(), std::ssize(v1)};
    auto r1 = std::ranges::subrange{i1, std::default_sentinel};
//  auto e1 = std::accumulate(r1.begin(), r1.end(), 0); // error: "common range" required
    auto c1 = std::ranges::common_view{r1};
    std::cout << "accumulate: " << std::accumulate(c1.begin(), c1.end(), 0) << '\n';
}
```

### ranges::reverse_view (C++20)

### views::reverse (C++20)
  
a view that iterates over the elements of another bidirectional view in reverse order

```c++
#include <iostream>
#include <ranges>
 
int main()
{
    static constexpr auto il = {3, 1, 4, 1, 5, 9};
 
    std::ranges::reverse_view rv{il};
    for (int i : rv)
        std::cout << i << ' ';
    std::cout << '\n';
 
    for (int i : il | std::views::reverse)
        std::cout << i << ' ';
    std::cout << '\n';
 
    // operator[] is inherited from std::view_interface
    for (auto i{0U}; i != rv.size(); ++i)
        std::cout << rv[i] << ' ';
    std::cout << '\n';
}
/*
9 5 1 4 1 3
9 5 1 4 1 3
9 5 1 4 1 3
*/
```

### ranges::as_const_view (C++23)

### views::as_const (C++23)

converts a view into a constant_range

```c++
#include <cassert>
#include <ranges>
 
int main()
{
    int x[]{1, 2, 3, 4, 5};
 
    auto v1 = x | std::views::drop(2);
    assert(v1.back() == 5);
    v1[0]++; // OK, can modify non-const element
 
    auto v2 = x | std::views::drop(2) | std::views::as_const; // <---------
    assert(v2.back() == 5);
    // v2[0]++; // Compile-time error, cannot modify read-only element
}
```

### ranges::as_rvalue_view (C++23)

### views::as_rvalue (C++23)

A view of a sequence that casts each element to an rvalue.
`std::ranges::as_rvalue_view`k is particularly useful when you want to move elements out of a container or range rather than copying them. By converting a range of lvalue references to rvalue references, it ensures that each element can be moved, which is more efficient than copying, especially for large or complex objects.

```c++
#include <iostream>
#include <vector>
#include <ranges>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hello", "World", "C++", "Ranges"};

    // Apply std::ranges::as_rvalue_view to the vector
    auto rvalue_range = std::ranges::as_rvalue_view(vec);

    // Move elements out of the vector
    std::vector<std::string> new_vec(rvalue_range.begin(), rvalue_range.end());

    // At this point, vec contains empty strings because elements were moved out
    for (const auto& s : vec) {
        std::cout << "\"" << s << "\"" << " "; // Outputs: "" "" "" ""
    }
    std::cout << std::endl;

    // new_vec now holds the moved strings
    for (const auto& s : new_vec) {
        std::cout << s << " "; // Outputs: "Hello World C++ Ranges"
    }
    std::cout << std::endl;

    return 0;
}
/*
"" "" "" "" 
Hello World C++ Ranges 
*/
```

### ranges::elements_view (C++20)

### views::elements (C++20)

takes a view consisting of tuple-like values and a number N and produces a view of Nth element of each tuple

```c++
#include <iostream>
#include <ranges>
#include <string>
#include <tuple>
#include <vector>
 
int main()
{
    const std::vector<std::tuple<int, char, std::string>> vt
    {
        {1, 'A', "Î±"},
        {2, 'B', "Î²"},
        {3, 'C', "Î³"},
        {4, 'D', "Î´"},
        {5, 'E', "Îµ"},
    };
 
    for (int const e : std::views::elements<0>(vt))
        std::cout << e << ' ';
    std::cout << '\n';
 
    for (char const e : vt | std::views::elements<1>)
        std::cout << e << ' ';
    std::cout << '\n';
 
    for (std::string const& e : std::views::elements<2>(vt))
        std::cout << e << ' ';
    std::cout << '\n';
}
/*
1 2 3 4 5
A B C D E
Î± Î² Î³ Î´ Îµ
*/
```

### ranges::keys_view (C++20)

### views::keys (C++20)
  
takes a view consisting of pair-like values and produces a view of the first elements of each pair

```c++
#include <iostream>
#include <map>
#include <ranges>

int main() {
    // Create a map of key-value pairs
    std::map<int, std::string> myMap = {
        {1, "One"},
        {2, "Two"},
        {3, "Three"},
        {4, "Four"}
    };

    // Create a keys_view from the map
    auto keys = std::views::keys(myMap);

    // Iterate over and print the keys
    for (int key : keys) {
        std::cout << key << std::endl;
    }

    return 0;
}
/*
1
2
3
4
*/
```

### ranges::values_view (C++20)

### views::values (C++20)

takes a view consisting of pair-like values and produces a view of the second elements of each pair

```c++
#include <iostream>
#include <map>
#include <ranges>
 
int main()
{
    const auto list = {std::pair{1, 11.1}, {2, 22.2}, {3, 33.3}};
    std::cout << "pair::second values in the list: ";
    for (double value : list | std::views::values)
        std::cout << value << ' ';
 
    std::map<char, int> map{{'A', 1}, {'B', 2}, {'C', 3}, {'D', 4}, {'E', 5}};
    auto odd = [](int x) { return 0 != (x & 1); };
    std::cout << "\nodd values in the map: ";
    for (int value : map | std::views::values | std::views::filter(odd))
        std::cout << value << ' ';
    std::cout << '\n';
}
```

### ranges::enumerate_view (C++23)

### views::enumerate (C++23)

a view that maps each element of adapted sequence to a tuple of both the element's position and its value

```c++
#include <iostream>
#include <vector>
#include <ranges>
#include <utility> // for std::pair

int main() {
    std::vector<int> numbers = {10, 20, 30, 40};

    // Create a custom enumerate-like view
    auto enumerate = std::views::iota(0) 
                   | std::views::transform([&](int i) {
                         return std::pair{i, numbers[i]};
                     });

    // Iterate over the custom enumerate view
    for (auto [index, value] : enumerate) {
        std::cout << "Index: " << index << ", Value: " << value << std::endl;
    }

    return 0;
}
/*
Index: 0, Value: 10
Index: 1, Value: 20
Index: 2, Value: 30
Index: 3, Value: 40
*/
```

### ranges::zip_view (C++23)

### views::zip (C++23)

a view consisting of tuples of references to corresponding elements of the adapted views

```C++
#include <array>
#include <iostream>
#include <list>
#include <ranges>
#include <string>
#include <tuple>
#include <vector>
 
void print(auto const rem, auto const& range)
{
    for (std::cout << rem; auto const& elem : range)
        std::cout << elem << ' ';
    std::cout << '\n';
}
 
int main()
{
    auto x = std::vector{1, 2, 3, 4};
    auto y = std::list<std::string>{"Î±", "Î²", "Î³", "Î´", "Îµ"};
    auto z = std::array{'A', 'B', 'C', 'D', 'E', 'F'};
 
    print("Source views:", "");
    print("x: ", x);
    print("y: ", y);
    print("z: ", z);
 
    print("\nzip(x,y,z):", "");
 
    for (std::tuple<int&, std::string&, char&> elem : std::views::zip(x, y, z))
    {
        std::cout << std::get<0>(elem) << ' '
                  << std::get<1>(elem) << ' '
                  << std::get<2>(elem) << '\n';
 
        std::get<char&>(elem) += ('a' - 'A'); // modifies the element of z
    }
 
    print("\nAfter modification, z: ", z);
}
/*
Source views:
x: 1 2 3 4
y: Î± Î² Î³ Î´ Îµ
z: A B C D E F
 
zip(x,y,z):
1 Î± A
2 Î² B
3 Î³ C
4 Î´ D
 
After modification, z: a b c d E F
*/
```

### ranges::zip_transform_view (C++23)

### views::zip_transform (C++23)

a view consisting of results of application of a transformation function to corresponding elements of the adapted views

```C++
#include <array>
#include <iostream>
#include <list>
#include <ranges>
#include <vector>
 
void print(auto const rem, auto const& r)
{
    std::cout << rem << '{'; 
    for (char o[]{0,' ',0}; auto const& e : r)
        std::cout << o << e, *o = ',';
    std::cout << "}\n";
}
 
int main()
{
    auto v1 = std::vector<float>{1, 2, 3};
    auto v2 = std::list<short>{1, 2, 3, 4};
    auto v3 = std::to_array({1, 2, 3, 4, 5});
 
    auto add = [](auto a, auto b, auto c) { return a + b + c; };
 
    auto sum = std::views::zip_transform(add, v1, v2, v3);
 
    print("v1:  ", v1);
    print("v2:  ", v2);
    print("v3:  ", v3);
    print("sum: ", sum);
}
/*
v1:  {1, 2, 3}
v2:  {1, 2, 3, 4}
v3:  {1, 2, 3, 4, 5}
sum: {3, 6, 9}
*/
```

### ranges::adjacent_view (C++23)

### views::adjacent (C++23)

a view consisting of tuples of references to adjacent elements of the adapted view

```c++
#include <iostream>
#include <ranges>
#include <vector>
#include <tuple>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Create a view that pairs adjacent elements in the vector
    auto adjacent_pairs = std::views::adjacent<2>(vec);

    // Iterate through the view and print each pair
    for (const auto& [first, second] : adjacent_pairs) {
        std::cout << '(' << first << ", " << second << ")\n";
    }

    return 0;
}
/*
(1, 2)
(2, 3)
(3, 4)
(4, 5)
(5, 6)
*/
```

### ranges::adjacent_transform_view (C++23)

### views::adjacent_transform (C++23)

a view consisting of results of application of a transformation function to adjacent elements of the adapted view

```c++
#include <array>
#include <iostream>
#include <ranges>
 
int main()
{
    constexpr static std::array data{1, 2, 3, 4, 5, 6};
    constexpr int window{3};
 
    auto Fun = [](auto... ints) { return (... + ints); };
    // Alternatively, the Fun could be any ternary (if window == 3) callable, e.g.:
    // auto Fun = [](int x, int y, int z) { return x + y + z; };
 
    constexpr auto view = data | std::views::adjacent_transform<window>(Fun);
 
    static_assert(
        view.size() == (data.size() - window + 1)
        && std::array{6, 9, 12, 15}
        == std::array{view[0], view[1], view[2], view[3]}
        && view[0] == Fun(data[0], data[1], data[2])
        && view[1] == Fun(data[1], data[2], data[3])
        && view[2] == Fun(data[2], data[3], data[4])
        && view[3] == Fun(data[3], data[4], data[5])
    );
 
    for (int x : view)
        std::cout << x << ' ';
    std::cout << '\n';
}
/*
6, 9, 12, 15
*/
```

```c++
#include <iostream>
#include <ranges>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Create a view that sums adjacent pairs of elements in the vector
    auto adjacent_sums = std::views::adjacent_transform<2>(vec, [](int a, int b) {
        return a + b;
    });

    // Iterate through the view and print each sum
    for (const auto& sum : adjacent_sums) {
        std::cout << sum << '\n';
    }

    return 0;
}
/*
3
5
7
9
11
*/
```

### ranges::join_with_view (C++23)

### views::join_with (C++23)

a view consisting of the sequence obtained from flattening a view of ranges, with the delimiter in between elements.
Note that `` is not added to the end of the array.

```c++
#include <iostream>
#include <ranges>
#include <string_view>
#include <vector>
 
int main()
{
    using namespace std::literals;
 
    std::vector v{"This"sv, "is"sv, "a"sv, "test."sv};
    auto joined = v | std::views::join_with(' ');
 
    for (auto c : joined)
        std::cout << c<<endl;;
    std::cout << "it's end"<<endl;
}
/*

T
h
i
s
 
i
s
 
a
 
t
e
s
t
.
it's end
*/
```

### ranges::stride_view (C++23)

### views::stride (C++23)
  
a view consisting of elements of another view, advancing over N elements at a time

```c++
#include <algorithm>
#include <iostream>
#include <ranges>
#include <string_view>
using namespace std::literals;
 
void print(std::ranges::viewable_range auto&& v, std::string_view separator = " ")
{
    for (auto const& x : v)
        std::cout << x << separator;
    std::cout << '\n';
}
 
int main()
{
    print(std::views::iota(1, 13) | std::views::stride(3));
    print(std::views::iota(1, 13) | std::views::stride(3) | std::views::reverse);
    print(std::views::iota(1, 13) | std::views::reverse | std::views::stride(3));
 
    print("0x0!133713337*x//42/A$@"sv | std::views::stride(0B11) |
          std::views::transform([](char O) -> char { return 0100 | O; }),
          "");
}
/*
1 4 7 10
10 7 4 1
12 9 6 3
password
*/
```

### ranges::slide_view (C++23)

### views::slide (C++23)

a view whose Mth element is a view over the Mth through (M + N - 1)th elements of another view

```c++
#include <iostream>
#include <ranges>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};

    // Create a sliding window view with a window size of 3
    auto sliding_windows = std::views::slide(vec, 3);

    // Iterate through the view and print each sliding window
    for (const auto& window : sliding_windows) {
        for (int value : window) {
            std::cout << value << ' ';
        }
        std::cout << '\n';
    }

    return 0;
}
/*
1 2 3 
2 3 4 
3 4 5 
4 5 6 
5 6 7 
6 7 8

*/
```

### ranges::chunk_view (C++23)

### views::chunk (C++23)

a range of views that are N-sized non-overlapping successive chunks of the elements of another view

```c++
#include <algorithm>
#include <iostream>
#include <ranges>
 
std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

auto chunked_view = std::views::chunk(vec, 3);

for (const auto& chunk : chunked_view) {
    for (int value : chunk) {
        std::cout << value << ' ';
    }
    std::cout << '\n';
}
/*
1 2 3 
4 5 6 
7 8 9 
10
*/
```

### ranges::chunk_by_view (C++23)

### views::chunk_by (C++23)

splits the view into subranges between each pair of adjacent elements for which the given predicate returns false

```c++
#include <functional>
#include <iostream>
#include <ranges>
#include <string_view>
 
void print_chunks(auto view, std::string_view separator = ", ")
{
    for (auto const subrange : view)
    {
        std::cout << '[';
        for (std::string_view prefix; auto const& elem : subrange)
            std::cout << prefix << elem, prefix = separator;
        std::cout << "] ";
    }
    std::cout << '\n';
}
 
int main()
{
    {
        std::initializer_list v = {1, 2, 3, 1, 2, 3, 3, 3, 1, 2, 3};
        auto fn = std::ranges::less{};
        auto view = v | std::views::chunk_by(fn);
        print_chunks(view);
    }
    {
        std::initializer_list v = {1, 2, 3, 4, 4, 0, 2, 3, 3, 3, 2, 1};
        auto fn = std::ranges::not_equal_to{};
        auto view = v | std::views::chunk_by(fn);
        print_chunks(view);
    }
    {
        std::string_view v = "__cpp_lib_ranges_chunk_by";
        auto fn = [](auto x, auto y) { return not(x == '_' or y == '_'); };
        auto view = v | std::views::chunk_by(fn);
        print_chunks(view, "");
    }
    {
        std::string_view v = "\u007a\u00df\u6c34\u{1f34c}"; // zÃŸæ°´ðŸŒ
        auto fn = [](auto, auto ÃŸ) { return (ÃŸ & (64 | 128)) == 128; };
        auto view = v | std::views::chunk_by(fn);
        print_chunks(view, "");
    }
}
/*
[1, 2, 3] [1, 2, 3] [3] [3] [1, 2, 3] 
[1, 2, 3, 4] [4, 0, 2, 3] [3] [3, 2, 1] 
[_] [_] [cpp] [_] [lib] [_] [ranges] [_] [chunk] [_] [by]
[z] [ÃŸ] [æ°´] [ðŸŒ]
*/
```

### ranges::stride_view and views::stride (C++23)

a view consisting of elements of another view, advancing over N elements at a time

```c++
#include <algorithm>
#include <iostream>
#include <ranges>
#include <string_view>
using namespace std::literals;
 
void print(std::ranges::viewable_range auto&& v, std::string_view separator = " ")
{
    for (auto const& x : v)
        std::cout << x << separator;
    std::cout << '\n';
}
 
int main()
{
    print(std::views::iota(1, 13) | std::views::stride(3));
    print(std::views::iota(1, 13) | std::views::stride(3) | std::views::reverse);
    print(std::views::iota(1, 13) | std::views::reverse | std::views::stride(3));
 
    print("0x0!133713337*x//42/A$@"sv | std::views::stride(0B11) |
          std::views::transform([](char O) -> char { return 0100 | O; }),
          "");
}
/*
1 4 7 10
10 7 4 1
12 9 6 3
password
*/
```

### ranges::cartesian_product_view (C++23)

### views::cartesian_product (C++23)

a view consisting of tuples of results calculated by the n-ary cartesian product of the adapted views

```c++
#include <array>
#include <iostream>
#include <list>
#include <ranges>
#include <string>
#include <vector>
 
void print(std::tuple<char const&, int const&, std::string const&> t, int pos)
{
    const auto& [a, b, c] = t;
    std::cout << '(' << a << ' ' << b << ' ' << c << ')' << (pos % 4 ? " " : "\n");
}
 
int main()
{
    const auto x = std::array{'A', 'B'};
    const auto y = std::vector{1, 2, 3};
    const auto z = std::list<std::string>{"Î±", "Î²", "Î³", "Î´"};
 
    for (int i{1}; auto const& tuple : std::views::cartesian_product(x, y, z))
        print(tuple, i++);
}
/*
(A 1 Î±) (A 1 Î²) (A 1 Î³) (A 1 Î´)
(A 2 Î±) (A 2 Î²) (A 2 Î³) (A 2 Î´)
(A 3 Î±) (A 3 Î²) (A 3 Î³) (A 3 Î´)
(B 1 Î±) (B 1 Î²) (B 1 Î³) (B 1 Î´)
(B 2 Î±) (B 2 Î²) (B 2 Î³) (B 2 Î´)
(B 3 Î±) (B 3 Î²) (B 3 Î³) (B 3 Î´)
*/
```

### ranges::concat_view (C++26)

### views::concat (C++26)

a view consisting of concatenation of the adapted views

```c++
#include <cassert>
#include <list>
#include <print>
#include <ranges>
#include <vector>
 
int main()
{
    std::vector<int> v0{1, 2, 3}, v1{4, 5};
    int a[]{6, 7};
    int i{8};
    auto ie{std::views::single(i)};
 
    auto con = std::views::concat(v0, v1, a, ie);
    assert(con.size() == v0.size() + v1.size() + std::size(a) + ie.size());
    std::println("con.size(): {}", con.size());
    std::println("con: {}", con);
    con[6] = 42; // con is random_access_range, operator[] returns a reference
    assert(a[1] == 42); // a[1] was modified via con[6]
    std::println("con: {}", con);
 
    std::list<int> l{7, 8}; // list is bidirectional range
    auto cat = std::views::concat(v0, l);
    std::println("cat: {}", cat);
    // cat[0] = 13; // compile-time error: cat is bidirectional => no operator[]
}
/*
con.size(): 8
con: [1, 2, 3, 4, 5, 6, 7, 8]
con: [1, 2, 3, 4, 5, 6, 42, 8]
cat: [1, 2, 3, 7, 8]
*/
```
